/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

package v1alpha1

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ProxyMessage struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProxyMessage) Reset()      { *m = ProxyMessage{} }
func (*ProxyMessage) ProtoMessage() {}
func (*ProxyMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *ProxyMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProxyMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProxyMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyMessage.Merge(m, src)
}
func (m *ProxyMessage) XXX_Size() int {
	return m.Size()
}
func (m *ProxyMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyMessage proto.InternalMessageInfo

type Request struct {
	// Id is used as identifier for all response messages for this
	// request. It is included in all ReplyMessages for this Request.
	Id       int64                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Method   string                 `protobuf:"bytes,2,opt,name=method,proto3" json:"method,omitempty"`
	Path     string                 `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	RawQuery string                 `protobuf:"bytes,4,opt,name=rawQuery,proto3" json:"rawQuery,omitempty"`
	Header   map[string]*RESTHeader `protobuf:"bytes,5,rep,name=header,proto3" json:"header,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Body contains the entire request body data.
	Body                 []byte   `protobuf:"bytes,6,opt,name=body,proto3" json:"body,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request) Reset()      { *m = Request{} }
func (*Request) ProtoMessage() {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Request) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *Request) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Request) GetRawQuery() string {
	if m != nil {
		return m.RawQuery
	}
	return ""
}

func (m *Request) GetHeader() map[string]*RESTHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Request) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type RESTHeader struct {
	Values               []string `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RESTHeader) Reset()      { *m = RESTHeader{} }
func (*RESTHeader) ProtoMessage() {}
func (*RESTHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *RESTHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RESTHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RESTHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RESTHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RESTHeader.Merge(m, src)
}
func (m *RESTHeader) XXX_Size() int {
	return m.Size()
}
func (m *RESTHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RESTHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RESTHeader proto.InternalMessageInfo

func (m *RESTHeader) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

// ReplyMessage is one of many replies that are sent
// by the proxy for each Request. If the error and/or close are set,
// then the request has failed and no further replies are going to
// be sent.
//
// The proxy waits for the ReplyResponse before sending the next
// ReplyMessage. This ensures that the gRPC server receives
// the body chunks in the right order.
type ReplyMessage struct {
	// Id matches the Id in the Request that this reply belongs to.
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Error is set if and only if executing the request encountered a problem.
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Close indicates that the end of the body has been reached.
	Close bool `protobuf:"varint,3,opt,name=close,proto3" json:"close,omitempty"`
	// Header contains the response from the REST server. It is
	// set in all reply messages.
	Header *ResponseHeader `protobuf:"bytes,4,opt,name=header,proto3" json:"header,omitempty"`
	// BodyOffset is the index of the body data in the overall response body.
	BodyOffset int64 `protobuf:"varint,5,opt,name=body_offset,json=bodyOffset,proto3" json:"body_offset,omitempty"`
	// Body contains some of the response body data.
	// The entire data is provided in chunks in multiple
	// replies. A reply may provide an error, indicate the
	// end of the response data, and contain some more data.
	Body                 []byte   `protobuf:"bytes,6,opt,name=body,proto3" json:"body,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReplyMessage) Reset()      { *m = ReplyMessage{} }
func (*ReplyMessage) ProtoMessage() {}
func (*ReplyMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *ReplyMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplyMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplyMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplyMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplyMessage.Merge(m, src)
}
func (m *ReplyMessage) XXX_Size() int {
	return m.Size()
}
func (m *ReplyMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplyMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ReplyMessage proto.InternalMessageInfo

func (m *ReplyMessage) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ReplyMessage) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *ReplyMessage) GetClose() bool {
	if m != nil {
		return m.Close
	}
	return false
}

func (m *ReplyMessage) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ReplyMessage) GetBodyOffset() int64 {
	if m != nil {
		return m.BodyOffset
	}
	return 0
}

func (m *ReplyMessage) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type ResponseHeader struct {
	Status     string                 `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	StatusCode int32                  `protobuf:"varint,2,opt,name=status_code,json=statusCode,proto3" json:"status_code,omitempty"`
	Proto      string                 `protobuf:"bytes,3,opt,name=proto,proto3" json:"proto,omitempty"`
	ProtoMajor int32                  `protobuf:"varint,4,opt,name=proto_major,json=protoMajor,proto3" json:"proto_major,omitempty"`
	ProtoMinor int32                  `protobuf:"varint,5,opt,name=proto_minor,json=protoMinor,proto3" json:"proto_minor,omitempty"`
	Header     map[string]*RESTHeader `protobuf:"bytes,6,rep,name=header,proto3" json:"header,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// ContentLength is the total expect length of the response body.
	ContentLength        int64    `protobuf:"varint,7,opt,name=content_length,json=contentLength,proto3" json:"content_length,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResponseHeader) Reset()      { *m = ResponseHeader{} }
func (*ResponseHeader) ProtoMessage() {}
func (*ResponseHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *ResponseHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseHeader.Merge(m, src)
}
func (m *ResponseHeader) XXX_Size() int {
	return m.Size()
}
func (m *ResponseHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseHeader proto.InternalMessageInfo

func (m *ResponseHeader) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ResponseHeader) GetStatusCode() int32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

func (m *ResponseHeader) GetProto() string {
	if m != nil {
		return m.Proto
	}
	return ""
}

func (m *ResponseHeader) GetProtoMajor() int32 {
	if m != nil {
		return m.ProtoMajor
	}
	return 0
}

func (m *ResponseHeader) GetProtoMinor() int32 {
	if m != nil {
		return m.ProtoMinor
	}
	return 0
}

func (m *ResponseHeader) GetHeader() map[string]*RESTHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ResponseHeader) GetContentLength() int64 {
	if m != nil {
		return m.ContentLength
	}
	return 0
}

type ReplyResponse struct {
	// Close is true if the client is not interested in receiving more reply data.
	Close                bool     `protobuf:"varint,1,opt,name=close,proto3" json:"close,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReplyResponse) Reset()      { *m = ReplyResponse{} }
func (*ReplyResponse) ProtoMessage() {}
func (*ReplyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *ReplyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplyResponse.Merge(m, src)
}
func (m *ReplyResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReplyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReplyResponse proto.InternalMessageInfo

func (m *ReplyResponse) GetClose() bool {
	if m != nil {
		return m.Close
	}
	return false
}

type NodeObjectRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Uid                  string   `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeObjectRequest) Reset()      { *m = NodeObjectRequest{} }
func (*NodeObjectRequest) ProtoMessage() {}
func (*NodeObjectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *NodeObjectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeObjectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeObjectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeObjectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeObjectRequest.Merge(m, src)
}
func (m *NodeObjectRequest) XXX_Size() int {
	return m.Size()
}
func (m *NodeObjectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeObjectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NodeObjectRequest proto.InternalMessageInfo

func (m *NodeObjectRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NodeObjectRequest) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

type NodeObjectResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeObjectResponse) Reset()      { *m = NodeObjectResponse{} }
func (*NodeObjectResponse) ProtoMessage() {}
func (*NodeObjectResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *NodeObjectResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeObjectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeObjectResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeObjectResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeObjectResponse.Merge(m, src)
}
func (m *NodeObjectResponse) XXX_Size() int {
	return m.Size()
}
func (m *NodeObjectResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeObjectResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NodeObjectResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ProxyMessage)(nil), "v1alpha1.ProxyMessage")
	proto.RegisterType((*Request)(nil), "v1alpha1.Request")
	proto.RegisterMapType((map[string]*RESTHeader)(nil), "v1alpha1.Request.HeaderEntry")
	proto.RegisterType((*RESTHeader)(nil), "v1alpha1.RESTHeader")
	proto.RegisterType((*ReplyMessage)(nil), "v1alpha1.ReplyMessage")
	proto.RegisterType((*ResponseHeader)(nil), "v1alpha1.ResponseHeader")
	proto.RegisterMapType((map[string]*RESTHeader)(nil), "v1alpha1.ResponseHeader.HeaderEntry")
	proto.RegisterType((*ReplyResponse)(nil), "v1alpha1.ReplyResponse")
	proto.RegisterType((*NodeObjectRequest)(nil), "v1alpha1.NodeObjectRequest")
	proto.RegisterType((*NodeObjectResponse)(nil), "v1alpha1.NodeObjectResponse")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 653 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x53, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0xcd, 0x26, 0x71, 0xda, 0x4e, 0xda, 0x88, 0xae, 0xaa, 0x62, 0x05, 0x08, 0x91, 0xd5, 0x4a,
	0x11, 0x52, 0x93, 0xb6, 0x08, 0x54, 0x2a, 0x4e, 0xa0, 0x4a, 0x20, 0x51, 0x0a, 0x86, 0x03, 0xe2,
	0x12, 0x6d, 0xec, 0x6d, 0xe2, 0xd6, 0xf1, 0x9a, 0xdd, 0x75, 0x21, 0x37, 0x3e, 0x81, 0x5f, 0xe1,
	0x23, 0x90, 0x7a, 0xe4, 0x06, 0x47, 0x1a, 0xbe, 0x03, 0x09, 0xed, 0xd8, 0x4e, 0x0c, 0x2d, 0x37,
	0x6e, 0xf3, 0xde, 0xce, 0xee, 0xbc, 0x79, 0x3b, 0x03, 0x4b, 0x2c, 0x0e, 0xba, 0xb1, 0x14, 0x5a,
	0xd0, 0xc5, 0xb3, 0x1d, 0x16, 0xc6, 0x23, 0xb6, 0xd3, 0xdc, 0x1a, 0x06, 0x7a, 0x94, 0x0c, 0xba,
	0x9e, 0x18, 0xf7, 0x86, 0x62, 0x28, 0x7a, 0x98, 0x30, 0x48, 0x8e, 0x11, 0x21, 0xc0, 0x28, 0xbd,
	0xe8, 0x34, 0x60, 0xf9, 0x85, 0x14, 0x1f, 0x26, 0x87, 0x5c, 0x29, 0x36, 0xe4, 0xce, 0x2f, 0x02,
	0x0b, 0x2e, 0x7f, 0x97, 0x70, 0xa5, 0x69, 0x03, 0xca, 0x81, 0x6f, 0x93, 0x36, 0xe9, 0x54, 0xdc,
	0x72, 0xe0, 0xd3, 0x75, 0xa8, 0x8d, 0xb9, 0x1e, 0x09, 0xdf, 0x2e, 0xb7, 0x49, 0x67, 0xc9, 0xcd,
	0x10, 0xa5, 0x50, 0x8d, 0x99, 0x1e, 0xd9, 0x15, 0x64, 0x31, 0xa6, 0x4d, 0x58, 0x94, 0xec, 0xfd,
	0xcb, 0x84, 0xcb, 0x89, 0x5d, 0x45, 0x7e, 0x86, 0xe9, 0x3d, 0xa8, 0x8d, 0x38, 0xf3, 0xb9, 0xb4,
	0xad, 0x76, 0xa5, 0x53, 0xdf, 0xbd, 0xd5, 0xcd, 0xd5, 0x77, 0xb3, 0xd2, 0xdd, 0x27, 0x78, 0x7e,
	0x10, 0x69, 0x39, 0x71, 0xb3, 0x64, 0x53, 0x66, 0x20, 0xfc, 0x89, 0x5d, 0x6b, 0x93, 0xce, 0xb2,
	0x8b, 0x71, 0xf3, 0x08, 0xea, 0x85, 0x54, 0x7a, 0x0d, 0x2a, 0xa7, 0x7c, 0x82, 0x92, 0x97, 0x5c,
	0x13, 0xd2, 0x3b, 0x60, 0x9d, 0xb1, 0x30, 0xe1, 0x28, 0xb9, 0xbe, 0xbb, 0x56, 0x28, 0x75, 0xf0,
	0xea, 0x75, 0x7a, 0xd7, 0x4d, 0x53, 0xf6, 0xcb, 0x7b, 0xc4, 0xd9, 0x00, 0x98, 0x1f, 0x98, 0x8e,
	0xf1, 0x48, 0xd9, 0xa4, 0x5d, 0x31, 0x1d, 0xa7, 0xc8, 0xf9, 0x4c, 0x60, 0xd9, 0xe5, 0x71, 0x98,
	0xdb, 0x76, 0xc9, 0xaa, 0x35, 0xb0, 0xb8, 0x94, 0x42, 0x66, 0x4e, 0xa5, 0xc0, 0xb0, 0x5e, 0x28,
	0x14, 0x47, 0xa7, 0x16, 0xdd, 0x14, 0xd0, 0xed, 0x99, 0x1d, 0x55, 0xd4, 0x68, 0x17, 0xed, 0x50,
	0xb1, 0x88, 0x14, 0xcf, 0x74, 0xe6, 0x4e, 0xdc, 0x86, 0xba, 0xe9, 0xbe, 0x2f, 0x8e, 0x8f, 0x15,
	0xd7, 0xb6, 0x85, 0x65, 0xc1, 0x50, 0x47, 0xc8, 0x5c, 0x65, 0x95, 0xf3, 0xad, 0x0c, 0x8d, 0x3f,
	0xdf, 0x33, 0xed, 0x29, 0xcd, 0x74, 0xa2, 0x32, 0xc7, 0x32, 0x64, 0xde, 0x4f, 0xa3, 0xbe, 0x27,
	0xfc, 0xd4, 0x3a, 0xcb, 0x85, 0x94, 0x7a, 0x2c, 0x7c, 0x6e, 0x1a, 0xc1, 0xf1, 0xc9, 0xbe, 0x3c,
	0x05, 0xe6, 0x1a, 0x06, 0xfd, 0x31, 0x3b, 0x11, 0x69, 0x37, 0x96, 0x0b, 0x48, 0x1d, 0x1a, 0xa6,
	0x90, 0x10, 0x44, 0x42, 0xa2, 0xee, 0x59, 0x82, 0x61, 0xe8, 0xc3, 0x99, 0x15, 0x35, 0x9c, 0x8c,
	0x8d, 0x7f, 0x59, 0x71, 0xe5, 0x80, 0x6c, 0x42, 0xc3, 0x13, 0x91, 0xe6, 0x91, 0xee, 0x87, 0x3c,
	0x1a, 0xea, 0x91, 0xbd, 0x80, 0xce, 0xac, 0x64, 0xec, 0x33, 0x24, 0xff, 0xff, 0xcc, 0x6c, 0xc2,
	0x0a, 0x0e, 0x43, 0x2e, 0x71, 0xfe, 0xcf, 0xa4, 0xf0, 0xcf, 0xce, 0x03, 0x58, 0x7d, 0x2e, 0x7c,
	0x7e, 0x34, 0x38, 0xe1, 0x9e, 0xce, 0x77, 0x8c, 0x42, 0x35, 0x62, 0x63, 0x9e, 0x95, 0xc7, 0xd8,
	0x28, 0x4a, 0x82, 0x7c, 0xc9, 0x4c, 0xe8, 0xac, 0x01, 0x2d, 0x5e, 0x4d, 0xcb, 0xec, 0x7e, 0x21,
	0x50, 0x35, 0x8a, 0xe8, 0x7d, 0xb0, 0x70, 0x89, 0xe9, 0xfa, 0x5c, 0x6a, 0x71, 0xab, 0x9b, 0xab,
	0x97, 0x36, 0xcc, 0x29, 0x6d, 0x13, 0xba, 0x0f, 0x16, 0x0a, 0x2f, 0xde, 0x2b, 0x8e, 0x75, 0xf3,
	0xfa, 0x5f, 0x7c, 0x5e, 0xda, 0x29, 0xd1, 0xa7, 0x00, 0x73, 0x49, 0xf4, 0xc6, 0x3c, 0xf1, 0x52,
	0x8f, 0xcd, 0x9b, 0x57, 0x1f, 0xe6, 0x4f, 0x3d, 0x7a, 0x73, 0x7e, 0xd1, 0x22, 0xdf, 0x2f, 0x5a,
	0xa5, 0x8f, 0xd3, 0x16, 0x39, 0x9f, 0xb6, 0xc8, 0xd7, 0x69, 0x8b, 0xfc, 0x98, 0xb6, 0xc8, 0xa7,
	0x9f, 0xad, 0xd2, 0xdb, 0xfd, 0xd3, 0x3d, 0xd5, 0x0d, 0x44, 0xcf, 0x9f, 0x44, 0x6c, 0x1c, 0x78,
	0x5b, 0x92, 0x2b, 0x91, 0x48, 0x8f, 0x6f, 0xb1, 0x30, 0x14, 0x1e, 0xd3, 0x81, 0x88, 0x7a, 0x2c,
	0x0e, 0x54, 0x4f, 0x72, 0xa5, 0x63, 0xd3, 0x75, 0x2f, 0x2f, 0x37, 0xa8, 0xe1, 0x6c, 0xdd, 0xfd,
	0x1d, 0x00, 0x00, 0xff, 0xff, 0xee, 0x49, 0xf1, 0x5d, 0x2a, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RESTClient is the client API for REST service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RESTClient interface {
	// Proxy is called by the REST proxy to enable sending
	// REST requests. It gets called again after errors.
	//
	// Each stream response is a single REST request. The response
	// is returned by the proxy through one or more Reply
	// calls.
	Proxy(ctx context.Context, in *ProxyMessage, opts ...grpc.CallOption) (REST_ProxyClient, error)
	// Reply provides part of the response for a REST request.
	Reply(ctx context.Context, in *ReplyMessage, opts ...grpc.CallOption) (*ReplyResponse, error)
	// NodeObject is called as soon as kubelet has information
	// about its node object. It's not called when used elsewhere.
	NodeObject(ctx context.Context, in *NodeObjectRequest, opts ...grpc.CallOption) (*NodeObjectResponse, error)
}

type rESTClient struct {
	cc *grpc.ClientConn
}

func NewRESTClient(cc *grpc.ClientConn) RESTClient {
	return &rESTClient{cc}
}

func (c *rESTClient) Proxy(ctx context.Context, in *ProxyMessage, opts ...grpc.CallOption) (REST_ProxyClient, error) {
	stream, err := c.cc.NewStream(ctx, &_REST_serviceDesc.Streams[0], "/v1alpha1.REST/Proxy", opts...)
	if err != nil {
		return nil, err
	}
	x := &rESTProxyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type REST_ProxyClient interface {
	Recv() (*Request, error)
	grpc.ClientStream
}

type rESTProxyClient struct {
	grpc.ClientStream
}

func (x *rESTProxyClient) Recv() (*Request, error) {
	m := new(Request)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rESTClient) Reply(ctx context.Context, in *ReplyMessage, opts ...grpc.CallOption) (*ReplyResponse, error) {
	out := new(ReplyResponse)
	err := c.cc.Invoke(ctx, "/v1alpha1.REST/Reply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rESTClient) NodeObject(ctx context.Context, in *NodeObjectRequest, opts ...grpc.CallOption) (*NodeObjectResponse, error) {
	out := new(NodeObjectResponse)
	err := c.cc.Invoke(ctx, "/v1alpha1.REST/NodeObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RESTServer is the server API for REST service.
type RESTServer interface {
	// Proxy is called by the REST proxy to enable sending
	// REST requests. It gets called again after errors.
	//
	// Each stream response is a single REST request. The response
	// is returned by the proxy through one or more Reply
	// calls.
	Proxy(*ProxyMessage, REST_ProxyServer) error
	// Reply provides part of the response for a REST request.
	Reply(context.Context, *ReplyMessage) (*ReplyResponse, error)
	// NodeObject is called as soon as kubelet has information
	// about its node object. It's not called when used elsewhere.
	NodeObject(context.Context, *NodeObjectRequest) (*NodeObjectResponse, error)
}

// UnimplementedRESTServer can be embedded to have forward compatible implementations.
type UnimplementedRESTServer struct {
}

func (*UnimplementedRESTServer) Proxy(req *ProxyMessage, srv REST_ProxyServer) error {
	return status.Errorf(codes.Unimplemented, "method Proxy not implemented")
}
func (*UnimplementedRESTServer) Reply(ctx context.Context, req *ReplyMessage) (*ReplyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reply not implemented")
}
func (*UnimplementedRESTServer) NodeObject(ctx context.Context, req *NodeObjectRequest) (*NodeObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodeObject not implemented")
}

func RegisterRESTServer(s *grpc.Server, srv RESTServer) {
	s.RegisterService(&_REST_serviceDesc, srv)
}

func _REST_Proxy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProxyMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RESTServer).Proxy(m, &rESTProxyServer{stream})
}

type REST_ProxyServer interface {
	Send(*Request) error
	grpc.ServerStream
}

type rESTProxyServer struct {
	grpc.ServerStream
}

func (x *rESTProxyServer) Send(m *Request) error {
	return x.ServerStream.SendMsg(m)
}

func _REST_Reply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplyMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RESTServer).Reply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1alpha1.REST/Reply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RESTServer).Reply(ctx, req.(*ReplyMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _REST_NodeObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RESTServer).NodeObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1alpha1.REST/NodeObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RESTServer).NodeObject(ctx, req.(*NodeObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _REST_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v1alpha1.REST",
	HandlerType: (*RESTServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Reply",
			Handler:    _REST_Reply_Handler,
		},
		{
			MethodName: "NodeObject",
			Handler:    _REST_NodeObject_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Proxy",
			Handler:       _REST_Proxy_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api.proto",
}

func (m *ProxyMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProxyMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Header) > 0 {
		for k := range m.Header {
			v := m.Header[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RawQuery) > 0 {
		i -= len(m.RawQuery)
		copy(dAtA[i:], m.RawQuery)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RawQuery)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RESTHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RESTHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RESTHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplyMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplyMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x32
	}
	if m.BodyOffset != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BodyOffset))
		i--
		dAtA[i] = 0x28
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Close {
		i--
		if m.Close {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResponseHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContentLength != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ContentLength))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Header) > 0 {
		for k := range m.Header {
			v := m.Header[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ProtoMinor != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ProtoMinor))
		i--
		dAtA[i] = 0x28
	}
	if m.ProtoMajor != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ProtoMajor))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Proto) > 0 {
		i -= len(m.Proto)
		copy(dAtA[i:], m.Proto)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Proto)))
		i--
		dAtA[i] = 0x1a
	}
	if m.StatusCode != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Close {
		i--
		if m.Close {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeObjectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeObjectRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeObjectRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeObjectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeObjectResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeObjectResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ProxyMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.RawQuery)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Header) > 0 {
		for k, v := range m.Header {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *RESTHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *ReplyMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Close {
		n += 2
	}
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BodyOffset != 0 {
		n += 1 + sovApi(uint64(m.BodyOffset))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ResponseHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.StatusCode != 0 {
		n += 1 + sovApi(uint64(m.StatusCode))
	}
	l = len(m.Proto)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ProtoMajor != 0 {
		n += 1 + sovApi(uint64(m.ProtoMajor))
	}
	if m.ProtoMinor != 0 {
		n += 1 + sovApi(uint64(m.ProtoMinor))
	}
	if len(m.Header) > 0 {
		for k, v := range m.Header {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.ContentLength != 0 {
		n += 1 + sovApi(uint64(m.ContentLength))
	}
	return n
}

func (m *ReplyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Close {
		n += 2
	}
	return n
}

func (m *NodeObjectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *NodeObjectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ProxyMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProxyMessage{`,
		`}`,
	}, "")
	return s
}
func (this *Request) String() string {
	if this == nil {
		return "nil"
	}
	keysForHeader := make([]string, 0, len(this.Header))
	for k := range this.Header {
		keysForHeader = append(keysForHeader, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHeader)
	mapStringForHeader := "map[string]*RESTHeader{"
	for _, k := range keysForHeader {
		mapStringForHeader += fmt.Sprintf("%v: %v,", k, this.Header[k])
	}
	mapStringForHeader += "}"
	s := strings.Join([]string{`&Request{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Method:` + fmt.Sprintf("%v", this.Method) + `,`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`RawQuery:` + fmt.Sprintf("%v", this.RawQuery) + `,`,
		`Header:` + mapStringForHeader + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RESTHeader) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RESTHeader{`,
		`Values:` + fmt.Sprintf("%v", this.Values) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplyMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplyMessage{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`Close:` + fmt.Sprintf("%v", this.Close) + `,`,
		`Header:` + strings.Replace(this.Header.String(), "ResponseHeader", "ResponseHeader", 1) + `,`,
		`BodyOffset:` + fmt.Sprintf("%v", this.BodyOffset) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseHeader) String() string {
	if this == nil {
		return "nil"
	}
	keysForHeader := make([]string, 0, len(this.Header))
	for k := range this.Header {
		keysForHeader = append(keysForHeader, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHeader)
	mapStringForHeader := "map[string]*RESTHeader{"
	for _, k := range keysForHeader {
		mapStringForHeader += fmt.Sprintf("%v: %v,", k, this.Header[k])
	}
	mapStringForHeader += "}"
	s := strings.Join([]string{`&ResponseHeader{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`StatusCode:` + fmt.Sprintf("%v", this.StatusCode) + `,`,
		`Proto:` + fmt.Sprintf("%v", this.Proto) + `,`,
		`ProtoMajor:` + fmt.Sprintf("%v", this.ProtoMajor) + `,`,
		`ProtoMinor:` + fmt.Sprintf("%v", this.ProtoMinor) + `,`,
		`Header:` + mapStringForHeader + `,`,
		`ContentLength:` + fmt.Sprintf("%v", this.ContentLength) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplyResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplyResponse{`,
		`Close:` + fmt.Sprintf("%v", this.Close) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeObjectRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeObjectRequest{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeObjectResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeObjectResponse{`,
		`}`,
	}, "")
	return s
}
func valueToStringApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ProxyMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawQuery", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawQuery = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = make(map[string]*RESTHeader)
			}
			var mapkey string
			var mapvalue *RESTHeader
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RESTHeader{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Header[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RESTHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RESTHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RESTHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Close", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Close = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyOffset", wireType)
			}
			m.BodyOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BodyOffset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoMajor", wireType)
			}
			m.ProtoMajor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtoMajor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoMinor", wireType)
			}
			m.ProtoMinor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtoMinor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = make(map[string]*RESTHeader)
			}
			var mapkey string
			var mapvalue *RESTHeader
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RESTHeader{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Header[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentLength", wireType)
			}
			m.ContentLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentLength |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Close", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Close = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeObjectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeObjectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeObjectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeObjectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeObjectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeObjectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
